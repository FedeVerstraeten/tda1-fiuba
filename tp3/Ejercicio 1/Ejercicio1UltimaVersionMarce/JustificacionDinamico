
Damos una justificación somera de por qué el algoritmo de ataque Dinámico obedece precisamente a la definición de programación dinámica.

En efecto, la programación dinámica (cfr. Wikipedia [2]) puede entenderse como el conjunto de técnicas de programación que obedecen los siguientes tres principios:

1.Dividir el problema original a resolver en subproblemas más pequeños.
2.Resolver estos problemas de manera óptima usando este proceso de tres pasos recursivamente.
3.Usar estas soluciones óptimas para construir una solución óptima al problema original.

En particular, para cada iteración o turno t, si k = NUM_TURRETS, nuestro enfoque para el algoritmo de ataque por programación dinámica obtiene los k primeros máximos en el siguiente conjunto:

G(t) = {g / g = g[i][j] es un elemento de la grilla de daños, y además existe un barco en g[i][j], en el turno t (i=0...NUM_FILAS, j=0...NUM_COLUMNAS) }

Atacaremos en paralelo a los barcos correspondientes a los elementos del conjunto G(t), con las NUM_TURRETS torretas.
Es decir, buscamos obtener los k primeros máximos del conjunto G(t), a cada turno t, con k = NUM_TURRETS.
Este problema se puede resolver de manera dinámica, viendo el problema de manera inductiva:

A tal efecto, buscamos entonces los k-1 primeros máximos del conjunto, donde k = NUM_TURRETS.

G'(t) = {g / g = g[i][j] es un elemento de la grilla de daños, y además existe un barco en g[i][j], en el turno t (i=0...NUM_FILAS-1, j=0...NUM_COLUMNAS) }, es decir, aplicamos inducción sobre NUM_FILAS.

Ahora bien, supongamos que tenemos el conjunto de los k-1 primeros máximos del conjunto G'(t). Podemos obtener fácilmente (inductivamente) los k primeros máximos del conjunto G(t) observando lo siguiente:

Sea q = g[k][j] el elemento de dano en la k-esima fila, esto es, j es la posición donde se encuentra el barco de la k-ésima fila en el turno t.

Si q es mayor que r = min { G(t) }, esto es, q es mayor que el mínimo de los k-1 primeros máximos de G', entonces q pertenece a G, y ahora el mínimo r queda afuera.

Este problema de los k-primeros máximos presenta recursividad de pila, y se puede reducir a una versión iterativa si admitimos que la grilla de danos presenta la siguiente particularidad: cada dano es un natural positivo, acotado (es decir, existe un MAX_DAMAGE).

En tal caso, tenemos la siguiente implementación, reduciendo la recursividad de pila:


function Player_PlayOneTurnDynamic() {
    Ships_AdvanceToTheRight();
    console.log("+ Avanzan los barcos hacia la derecha!");

    var turretsavailable = NUM_TURRETS;
    for (var i = 0; i < NUM_BARCOS; i++) {
        if (!ships[i].isDead) {
            var column = ships[i].column;
            for (var k = GRID_DAMAGE_MAX; k >= 0; k--) {
                if (grid[i][column] == k) {
                    //atacar!
                    ships[i].life = ships[i].life - grid[i][column];
                    turretsavailable--;
                    if (ships[i].life <= 0) {
                        ships[i].isDead = true;
                    }

                    if (turretsavailable == 0) return;

                }
            }
        }
    }
}

Es decir, atacamos en paralelo en cada turno, los k = NUM_TURRETS primeros máximos de la grilla de danos, para aquellos barcos que estén vivos, desde luego.




